int non_interactive_mode(char *av[])
{
    char *line = NULL;
    size_t len = 0;
    char **args;
    pid_t pid;
    char *cmd;
    int status, exitStatus = 0, counter = 1;
    ssize_t read;
    struct stat st;

    while ((read = getline(&line, &len, stdin)) != -1)
    {
        if (line[read - 1] == '\n')
        {
            line[read - 1] = '\0';
        }
        args = _arguments(line);
		/***************/
// 		int i = 0;
// 		while (args[i] != NULL)
// {
//     printf("args[%d]: %s\n", i, args[i]);
//     i++;
// }
		/****************/
        if (!args[0])
        {
            counter++;
            free_arguments(args);
            continue;
        }
        else if (_strcmp(args[0], "exit") == 0)
        {
            exitStatus = exit_shell(args, av, counter, line);
            break;
        }
        else if (_strcmp(args[0], "env") == 0)
        {
            exitStatus = _env(args);
            free_arguments(args);
            continue;
        }
		// printf("+++++++++++%s\n",args[0]);S
		cmd = _cmd(args[0]);
		// printf("Command to execute: %s\n", cmd);
    	if (!cmd)
        {
            _exit_127(av, counter, args);
            free_arguments(args);
            exitStatus = 127;  // Set the exit status to indicate command not found
            continue;  // Skip command execution if cmd is NULL
        }
        pid = fork();
        if (pid < 0)
        {
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid == 0)
        {
            if (execve(cmd, args, environ) == -1)
            {
                perror("execve");
            }
			
            free(cmd);
            free_arguments(args);
            free(line);
            // exit(127);
        }
        else
        {
            wait(&status);
			if (WIFEXITED(status))
			{
				int commandExitStatus = WEXITSTATUS(status);
				if (commandExitStatus != 0)
				{
					exitStatus = commandExitStatus;  // Update status only if non-zero
				}
			}

        }
		
        free(cmd);
        free_arguments(args);
        counter++;
    }
    free(line);
    return exitStatus;  // Return the overall exit status after loop completion
}

//  int non_interactive_mode(char *av[])
//  {
//  	char *line = NULL;
//  	size_t len = 0;
//  	char **args;
//  	pid_t pid;
//  	char *cmd;
//  	int status, exitStatus = 0, counter = 1;
//  	ssize_t read;
//  	struct stat st;

//  	while ((read = getline(&line, &len, stdin)) != -1)
//  	{
//  		if (line[read - 1] == '\n')
//  		{
//  			line[read - 1] = '\0';
//  		}
//  		args = _arguments(line);
//  		if (!args[0])
//  		{ counter++;
//  			free_arguments(args);
//  			continue; }
//  		else if (_strcmp(args[0], "exit") == 0)
//  		{
//  			exitStatus = exit_shell(args, av, counter, line);
//  			break; }
//          else if (_strcmp(args[0], "env") == 0)
//  		{
//  			exitStatus = _env(args);
//  			//  free_arguments(args);
//  			continue; }
//  		pid = fork();
//  		if (pid < 0)
//  		{
//  			perror("fork");
//  			exit(EXIT_FAILURE); }
//          else if (pid == 0)
//  		{
//  			cmd = _cmd(args[0]);

//  			if (cmd)
//  			{
//  				if (execve(cmd, args, environ) == -1)
//                  {
//  				perror("execve"); } }
//  			else
//  			{
//  				free_arguments(args);
//  				free(cmd);
//  				free(line);
//  				exit(127); }
//  		}
//  		else
//  		{
//  			wait(&status);
//  			if (WIFEXITED(status))
//  			{
//  				exitStatus = WEXITSTATUS(status);
//  				if (exitStatus == 127)
//  				{
//  					_exit_127(av, counter, args);
//  				} } }
//  		free_arguments(args);
//  		counter++; }
//  	free(line);
//  	return (exitStatus);
//  }
